import httpx
import re
from typing import Dict, Any, List
from app.core.config import settings


class AIContentDetectionService:
    def __init__(self):
        self.client = httpx.AsyncClient()

    async def detect_ai_content(self, text: str) -> Dict[str, Any]:
        sections = self._split_into_sections(text)
        section_results = {}
        winston_api_used = False

        for section_name, section_text in sections.items():
            if len(section_text.strip()) > 50:
                ai_probability, used_api = await self._analyze_section(section_text)
                section_results[section_name] = ai_probability
                if used_api:
                    winston_api_used = True

        overall_probability = self._calculate_overall_probability(section_results)
        suspicious_sections = [
            name for name, prob in section_results.items() if prob > 0.7
        ]

        confidence = self._calculate_confidence(section_results, winston_api_used)

        return {
            "overall_ai_probability": overall_probability,
            "sections_analyzed": section_results,
            "suspicious_sections": suspicious_sections,
            "confidence": confidence,
        }

    def _split_into_sections(self, text: str) -> Dict[str, str]:
        sections = {"summary": "", "experience": "", "skills": "", "education": ""}

        lines = text.split("\n")
        current_section = "summary"

        for line in lines:
            line_lower = line.lower().strip()

            if any(
                keyword in line_lower
                for keyword in ["experience", "work history", "employment"]
            ):
                current_section = "experience"
            elif any(
                keyword in line_lower
                for keyword in ["skills", "technical skills", "competencies"]
            ):
                current_section = "skills"
            elif any(
                keyword in line_lower for keyword in ["education", "academic", "degree"]
            ):
                current_section = "education"

            sections[current_section] += line + "\n"

        return sections

    async def _analyze_section(self, text: str) -> tuple[float, bool]:
        if not settings.WINSTON_AI_API_KEY:
            return self._basic_ai_detection(text), False

        try:
            response = await self.client.post(
                settings.WINSTON_AI_API,
                headers={
                    "Authorization": f"Bearer {settings.WINSTON_AI_API_KEY}",
                    "Content-Type": "application/json",
                },
                json={
                    "text": text,
                    "version": "latest",
                    "sentences": False,
                    "language": "en",
                },
            )

            if response.status_code == 200:
                data = response.json()

                if "error" in data or data.get("status") != 200:
                    return self._basic_ai_detection(text), False

                ai_score = float(data.get("score", 0.0))
                return ai_score / 100.0, True
        except Exception:
            pass

        return self._basic_ai_detection(text), False

    def _basic_ai_detection(self, text: str) -> float:
        ai_indicators = [
            r"\bas an ai\b",
            r"\bi am an ai\b",
            r"\bai-generated\b",
            r"\bgenerated by\b",
            r"\bai assistant\b",
            r"\blarge language model\b",
        ]

        generic_phrases = [
            r"\bexcellent communication skills\b",
            r"\bstrong problem-solving abilities\b",
            r"\bteam player\b",
            r"\bdetail-oriented\b",
            r"\bresults-driven\b",
        ]

        ai_score = 0.0
        generic_score = 0.0

        text_lower = text.lower()

        for pattern in ai_indicators:
            if re.search(pattern, text_lower):
                ai_score += 0.3

        for pattern in generic_phrases:
            if re.search(pattern, text_lower):
                generic_score += 0.1

        return min(ai_score + (generic_score * 0.5), 1.0)

    def _calculate_overall_probability(
        self, section_results: Dict[str, float]
    ) -> float:
        if not section_results:
            return 0.0

        weights = {"summary": 0.3, "experience": 0.4, "skills": 0.2, "education": 0.1}

        weighted_sum = 0.0
        total_weight = 0.0

        for section, probability in section_results.items():
            weight = weights.get(section, 0.1)
            weighted_sum += probability * weight
            total_weight += weight

        return weighted_sum / total_weight if total_weight > 0 else 0.0

    def _calculate_confidence(
        self, section_results: Dict[str, float], winston_api_used: bool
    ) -> float:
        base_confidence = 0.9 if winston_api_used else 0.6

        if not section_results:
            return base_confidence * 0.5

        score_variance = 0.0
        if len(section_results) > 1:
            scores = list(section_results.values())
            mean_score = sum(scores) / len(scores)
            score_variance = sum((score - mean_score) ** 2 for score in scores) / len(
                scores
            )

        consistency_factor = max(0.7, 1.0 - score_variance)
        section_count_factor = min(1.0, len(section_results) / 3.0)

        return base_confidence * consistency_factor * section_count_factor

    async def close(self):
        await self.client.aclose()
